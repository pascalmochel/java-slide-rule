/*
 * Copyright (C) 2009, 2010 M. Lechouga
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.morm.session;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.morm.criteria.Criteria;
import org.morm.exception.SormException;
import org.morm.mapper.DataMapper;
import org.morm.record.Entity;
import org.morm.test.Dog;
import org.morm.test.EntityTest2;

import static org.junit.Assert.*;

public class NestedTransactionsTest {

	static {
		new EntityTest2();
	}

	@Before
	public void before() {
		SessionFactory.getSession().open();

		DataMapper.executeDDLIgnoringErrors("DROP TABLE DOG");
		DataMapper.executeDDLIgnoringErrors("DROP TABLE RABBIT");

		DataMapper.executeDDL(
		/**/"CREATE TABLE RABBIT (" +
		/**/"ID_RABBIT INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 100) PRIMARY KEY," +
		/**/"NAME VARCHAR(20)," +
		/**/"AGE INTEGER," +
		/**/"NUM_DOG INTEGER)"
		/**/);
		DataMapper.executeDDL(
		/**/"CREATE TABLE DOG (" +
		/**/"ID_DOG INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 100) PRIMARY KEY," +
		/**/"NAME VARCHAR(20)," +
		/**/"AGE INTEGER)"
		/**/);
		SessionFactory.getSession().commit();
	}

	@After
	public void after() {
		SessionFactory.getSession().open();
		DataMapper.executeDDL("DROP TABLE RABBIT");
		DataMapper.executeDDL("DROP TABLE DOG");
		SessionFactory.getSession().commit();
	}

	@Test
	public void testProgram1() {
		testMachine("{0+1{+2}1+2}{0}");
	}

	@Test
	public void testProgram2() {
		testMachine("{0+1{+2]2+3}{0}");
	}

	/**
	 * aquest cas no pot ser, ja que en cas d'error, es fa rollback i l'excepció
	 * es propaga causant també rollback als altres nivells
	 */
	@Test
	public void testProgram3() {
		testMachine("{0+1{+2}1+2]{2}");
	}

	@Test
	public void testProgram4() {
		testMachine("{0+1{+2]2+3]{3}");
	}

	@Test
	public void testProgram5() {
		testMachine("{0+1{+2{+3]3]3+4]{4}");
	}

	@Test
	public void testProgram7() {
		testMachine("{0+1{+2{+3}2}1+2]{2}");
	}

	@Test
	public void testProgram8() {
		testMachine("{0+1{+2{+3}2}1+2}{0}");
	}

	@Test
	public void testProgram9() {
		testMachine("{0+1{+2{+3]3+4]4+5}{0}");
	}

	public void testMachine(final String symbolProgram) {

		try {
			SessionFactory.getSession().open();
			for (int i = 0; i < symbolProgram.length(); i++) {
				execSymbol(symbolProgram.charAt(i));
			}
			SessionFactory.getSession().rollback();
		} catch (final Exception e) {
			throw new SormException("in program: " + symbolProgram, e);
		}
	}

	private void execSymbol(final char c) {
		switch (c) {
		case '{':
			SessionFactory.getSession().open();
			break;
		case '+':
			new Dog(null, "jou", 29).store();
			break;
		case '}':
			SessionFactory.getSession().rollback();
			break;
		case ']':
			SessionFactory.getSession().commit();
			break;
		default:
			assertEquals(Long.valueOf(String.valueOf(c)), Entity.count(Dog.class, Criteria.all()));
		}
	}

}
