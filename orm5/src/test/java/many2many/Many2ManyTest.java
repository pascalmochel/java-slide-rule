package many2many;

import many2many.ent.A;
import many2many.ent.AB;
import many2many.ent.B;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.orm.criteria.Criteria;
import org.orm.mapper.DataMapper;
import org.orm.session.SessionFactory;
import org.orm.test.EntityTest2;

import java.util.Arrays;

import static org.junit.Assert.*;

public class Many2ManyTest {

	static {
		new EntityTest2();
	}

	@Before
	public void before() {
		SessionFactory.getSession().open();

		DataMapper.executeDDLIgnoringErrors("DROP TABLE A");
		DataMapper.executeDDLIgnoringErrors("DROP TABLE B");
		DataMapper.executeDDLIgnoringErrors("DROP TABLE AB");

		DataMapper.executeDDL(
		/**/"CREATE TABLE AB (" +
		/**/"ID_AB BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) PRIMARY KEY," +
		/**/"ID_A INTEGER," +
		/**/"ID_B INTEGER)"
		/**/);
		DataMapper.executeDDL(
		/**/"CREATE TABLE A(" +
		/**/"ID_A INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 100) PRIMARY KEY)"
		/**/);
		DataMapper.executeDDL(
		/**/"CREATE TABLE B(" +
		/**/"ID_B INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 100) PRIMARY KEY)"
		/**/);
		SessionFactory.getSession().commit();
	}

	@After
	public void after() {
		SessionFactory.getSession().open();
		DataMapper.executeDDLIgnoringErrors("DROP TABLE A");
		DataMapper.executeDDLIgnoringErrors("DROP TABLE B");
		DataMapper.executeDDLIgnoringErrors("DROP TABLE AB");
		SessionFactory.getSession().commit();
	}

	@Test
	public void testA() throws Exception {

		SessionFactory.getSession().open();

		try {

			final A a = new A();
			final B b = new B();
			final AB ab = new AB();
			{

				// per storar, s'han d'establir les relacions en ordre:
				// store(A): A=>AB=>B
				// store(AB): AB=>A, AB=>B
				a.setAbs(Arrays.asList(ab));
				ab.setB(b);
				a.store();

				// havent storat, les id<=>fk s'han setejat, ...
				assertEquals("[ID_A=100, [[ID_AB=100, ID_A=100=>[...], ID_B=100=>[ID_B=100, [...]]]]]", a
						.toString());

				// ... i es pot navegar com es vulgui
				assertTrue(a == a.getAbs().get(0).getA());
			}

			SessionFactory.getSession().getIdCache().clear();

			{
				final A q = Criteria.selectById(A.class, a.getId());
				assertEquals("[ID_A=100, [...]]", q.toString());
				q.getAbs(); // activa el lazy
				assertEquals("[ID_A=100, [[ID_AB=100, ID_A=100=>[...], ID_B=100=>[...]]]]", q.toString());
				q.getAbs().get(0).getB();// activa el lazy
				assertEquals("[ID_A=100, [[ID_AB=100, ID_A=100=>[...], ID_B=100=>[ID_B=100, [...]]]]]", q
						.toString());

				// funciona si està dins de transacció
				assertTrue(q == q.getAbs().get(0).getA());
				assertTrue(q == q.getAbs().get(0).getB().getAbs().get(0).getA());
			}
		} catch (final Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			SessionFactory.getSession().rollback();
		}
	}

	@Test
	public void testAB() {

		SessionFactory.getSession().open();

		try {

			final AB ab = new AB();
			{
				final A a = new A();
				final B b = new B();

				ab.setA(a);
				ab.setB(b);

				ab.store();
			}

			SessionFactory.getSession().getIdCache().clear();

			{
				final AB q = Criteria.selectById(AB.class, ab.getId());
				assertEquals("[ID_AB=100, ID_A=100=>[...], ID_B=100=>[...]]", q.toString());
				q.getA();
				q.getB();
				assertEquals("[ID_AB=100, ID_A=100=>[ID_A=100, [...]], ID_B=100=>[ID_B=100, [...]]]", q
						.toString());
			}

		} finally {
			SessionFactory.getSession().rollback();
		}
	}

	@Test
	public void testLoadOutsideTX() throws Exception {

		SessionFactory.getSession().open();
		try {
			final A a = new A();
			final B b = new B();
			final AB ab = new AB();

			a.setAbs(Arrays.asList(ab));
			ab.setB(b);
			a.store();

			SessionFactory.getSession().getIdCache().clear();
		} finally {
			SessionFactory.getSession().commit();
		}

		SessionFactory.getSession().open();
		A a2;
		try {
			a2 = Criteria.selectById(A.class, 100);
		} finally {
			SessionFactory.getSession().rollback();
		}

		// fora de Tx worka!
		a2.getAbs().get(0).getB().getAbs().get(0).getA();

		// falla fora de Tx pq en recuperar colaboradors s'inicia sessió i es
		// perd la identityMap
		try {
			assertTrue(a2 == a2.getAbs().get(0).getA());
			assertTrue(a2 == a2.getAbs().get(0).getB().getAbs().get(0).getA());
			fail();
		} catch (final AssertionError e) {
		}
	}

}
